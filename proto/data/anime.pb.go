// Code generated by protoc-gen-go. DO NOT EDIT.
// source: data/anime.proto

package data

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Type of an anime episode
type Episode_Type int32

const (
	Episode_UNKNOWN Episode_Type = 0
	Episode_REGULAR Episode_Type = 1
	Episode_SPECIAL Episode_Type = 2
)

var Episode_Type_name = map[int32]string{
	0: "UNKNOWN",
	1: "REGULAR",
	2: "SPECIAL",
}

var Episode_Type_value = map[string]int32{
	"UNKNOWN": 0,
	"REGULAR": 1,
	"SPECIAL": 2,
}

func (x Episode_Type) String() string {
	return proto.EnumName(Episode_Type_name, int32(x))
}

func (Episode_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_026676bd538d663f, []int{0, 0}
}

// Type of an anime title
type Anime_Type int32

const (
	Anime_UNKNOWN   Anime_Type = 0
	Anime_TV_SERIES Anime_Type = 1
	Anime_OVA       Anime_Type = 2
	Anime_ONA       Anime_Type = 3
	Anime_MOVIE     Anime_Type = 4
	Anime_SPECIAL   Anime_Type = 5
)

var Anime_Type_name = map[int32]string{
	0: "UNKNOWN",
	1: "TV_SERIES",
	2: "OVA",
	3: "ONA",
	4: "MOVIE",
	5: "SPECIAL",
}

var Anime_Type_value = map[string]int32{
	"UNKNOWN":   0,
	"TV_SERIES": 1,
	"OVA":       2,
	"ONA":       3,
	"MOVIE":     4,
	"SPECIAL":   5,
}

func (x Anime_Type) String() string {
	return proto.EnumName(Anime_Type_name, int32(x))
}

func (Anime_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_026676bd538d663f, []int{1, 0}
}

// Anime episode
type Episode struct {
	// Episode type
	Type Episode_Type `protobuf:"varint,1,opt,name=type,proto3,enum=data.Episode_Type" json:"type,omitempty"`
	// Episode number
	Number int32 `protobuf:"zigzag32,2,opt,name=number,proto3" json:"number,omitempty"`
	// Episode name
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// Episode duration in seconds
	Duration float64 `protobuf:"fixed64,4,opt,name=duration,proto3" json:"duration,omitempty"`
	// Timestamp of the episode air date (unix time)
	AirDate              int64    `protobuf:"zigzag64,5,opt,name=air_date,json=airDate,proto3" json:"air_date,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Episode) Reset()         { *m = Episode{} }
func (m *Episode) String() string { return proto.CompactTextString(m) }
func (*Episode) ProtoMessage()    {}
func (*Episode) Descriptor() ([]byte, []int) {
	return fileDescriptor_026676bd538d663f, []int{0}
}

func (m *Episode) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Episode.Unmarshal(m, b)
}
func (m *Episode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Episode.Marshal(b, m, deterministic)
}
func (m *Episode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Episode.Merge(m, src)
}
func (m *Episode) XXX_Size() int {
	return xxx_messageInfo_Episode.Size(m)
}
func (m *Episode) XXX_DiscardUnknown() {
	xxx_messageInfo_Episode.DiscardUnknown(m)
}

var xxx_messageInfo_Episode proto.InternalMessageInfo

func (m *Episode) GetType() Episode_Type {
	if m != nil {
		return m.Type
	}
	return Episode_UNKNOWN
}

func (m *Episode) GetNumber() int32 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *Episode) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Episode) GetDuration() float64 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *Episode) GetAirDate() int64 {
	if m != nil {
		return m.AirDate
	}
	return 0
}

// Anime title
type Anime struct {
	// Anime ids in external databases
	Source *Anime_Source `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	// Anime type
	Type Anime_Type `protobuf:"varint,2,opt,name=type,proto3,enum=data.Anime_Type" json:"type,omitempty"`
	// Canonical anime title in romaji
	Title string `protobuf:"bytes,3,opt,name=title,proto3" json:"title,omitempty"`
	// URL of the anime poster
	PosterUrl string `protobuf:"bytes,4,opt,name=poster_url,json=posterUrl,proto3" json:"poster_url,omitempty"`
	// Number of the anime episodes
	EpisodesCount int32 `protobuf:"zigzag32,5,opt,name=episodes_count,json=episodesCount,proto3" json:"episodes_count,omitempty"`
	// Known anime episodes info
	Episodes []*Episode `protobuf:"bytes,6,rep,name=episodes,proto3" json:"episodes,omitempty"`
	// Timestamp of the anime start air date (unix)
	StartDate int64 `protobuf:"zigzag64,7,opt,name=start_date,json=startDate,proto3" json:"start_date,omitempty"`
	// Timestamp of the anime end air date (unix)
	EndDate int64 `protobuf:"zigzag64,8,opt,name=end_date,json=endDate,proto3" json:"end_date,omitempty"`
	// Anime tags (same as genre in some external sources)
	Tags []*Anime_Tag `protobuf:"bytes,9,rep,name=tags,proto3" json:"tags,omitempty"`
	// Anime rating
	Rating float64 `protobuf:"fixed64,10,opt,name=rating,proto3" json:"rating,omitempty"`
	// Anime description
	Description string `protobuf:"bytes,11,opt,name=description,proto3" json:"description,omitempty"`
	// Creation date in external DB
	SrcCreatedAt int64 `protobuf:"zigzag64,12,opt,name=src_created_at,json=srcCreatedAt,proto3" json:"src_created_at,omitempty"`
	// Last update date in external DB
	SrcUpdatedAt         int64    `protobuf:"zigzag64,13,opt,name=src_updated_at,json=srcUpdatedAt,proto3" json:"src_updated_at,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Anime) Reset()         { *m = Anime{} }
func (m *Anime) String() string { return proto.CompactTextString(m) }
func (*Anime) ProtoMessage()    {}
func (*Anime) Descriptor() ([]byte, []int) {
	return fileDescriptor_026676bd538d663f, []int{1}
}

func (m *Anime) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Anime.Unmarshal(m, b)
}
func (m *Anime) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Anime.Marshal(b, m, deterministic)
}
func (m *Anime) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Anime.Merge(m, src)
}
func (m *Anime) XXX_Size() int {
	return xxx_messageInfo_Anime.Size(m)
}
func (m *Anime) XXX_DiscardUnknown() {
	xxx_messageInfo_Anime.DiscardUnknown(m)
}

var xxx_messageInfo_Anime proto.InternalMessageInfo

func (m *Anime) GetSource() *Anime_Source {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *Anime) GetType() Anime_Type {
	if m != nil {
		return m.Type
	}
	return Anime_UNKNOWN
}

func (m *Anime) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Anime) GetPosterUrl() string {
	if m != nil {
		return m.PosterUrl
	}
	return ""
}

func (m *Anime) GetEpisodesCount() int32 {
	if m != nil {
		return m.EpisodesCount
	}
	return 0
}

func (m *Anime) GetEpisodes() []*Episode {
	if m != nil {
		return m.Episodes
	}
	return nil
}

func (m *Anime) GetStartDate() int64 {
	if m != nil {
		return m.StartDate
	}
	return 0
}

func (m *Anime) GetEndDate() int64 {
	if m != nil {
		return m.EndDate
	}
	return 0
}

func (m *Anime) GetTags() []*Anime_Tag {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Anime) GetRating() float64 {
	if m != nil {
		return m.Rating
	}
	return 0
}

func (m *Anime) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Anime) GetSrcCreatedAt() int64 {
	if m != nil {
		return m.SrcCreatedAt
	}
	return 0
}

func (m *Anime) GetSrcUpdatedAt() int64 {
	if m != nil {
		return m.SrcUpdatedAt
	}
	return 0
}

// External DB location
type Anime_Source struct {
	// AniDB id
	AnidbIds []int32 `protobuf:"zigzag32,1,rep,packed,name=anidb_ids,json=anidbIds,proto3" json:"anidb_ids,omitempty"`
	// MyAnimeList id
	MalIds []int32 `protobuf:"zigzag32,2,rep,packed,name=mal_ids,json=malIds,proto3" json:"mal_ids,omitempty"`
	// AnimeNewsNetwork id
	AnnIds               []int32  `protobuf:"zigzag32,3,rep,packed,name=ann_ids,json=annIds,proto3" json:"ann_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Anime_Source) Reset()         { *m = Anime_Source{} }
func (m *Anime_Source) String() string { return proto.CompactTextString(m) }
func (*Anime_Source) ProtoMessage()    {}
func (*Anime_Source) Descriptor() ([]byte, []int) {
	return fileDescriptor_026676bd538d663f, []int{1, 0}
}

func (m *Anime_Source) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Anime_Source.Unmarshal(m, b)
}
func (m *Anime_Source) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Anime_Source.Marshal(b, m, deterministic)
}
func (m *Anime_Source) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Anime_Source.Merge(m, src)
}
func (m *Anime_Source) XXX_Size() int {
	return xxx_messageInfo_Anime_Source.Size(m)
}
func (m *Anime_Source) XXX_DiscardUnknown() {
	xxx_messageInfo_Anime_Source.DiscardUnknown(m)
}

var xxx_messageInfo_Anime_Source proto.InternalMessageInfo

func (m *Anime_Source) GetAnidbIds() []int32 {
	if m != nil {
		return m.AnidbIds
	}
	return nil
}

func (m *Anime_Source) GetMalIds() []int32 {
	if m != nil {
		return m.MalIds
	}
	return nil
}

func (m *Anime_Source) GetAnnIds() []int32 {
	if m != nil {
		return m.AnnIds
	}
	return nil
}

// Anime tag
type Anime_Tag struct {
	// Tag id in external db
	//
	// Types that are valid to be assigned to Source:
	//	*Anime_Tag_AnidbId
	Source isAnime_Tag_Source `protobuf_oneof:"source"`
	// Tag name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Tag description
	Description          string   `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Anime_Tag) Reset()         { *m = Anime_Tag{} }
func (m *Anime_Tag) String() string { return proto.CompactTextString(m) }
func (*Anime_Tag) ProtoMessage()    {}
func (*Anime_Tag) Descriptor() ([]byte, []int) {
	return fileDescriptor_026676bd538d663f, []int{1, 1}
}

func (m *Anime_Tag) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Anime_Tag.Unmarshal(m, b)
}
func (m *Anime_Tag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Anime_Tag.Marshal(b, m, deterministic)
}
func (m *Anime_Tag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Anime_Tag.Merge(m, src)
}
func (m *Anime_Tag) XXX_Size() int {
	return xxx_messageInfo_Anime_Tag.Size(m)
}
func (m *Anime_Tag) XXX_DiscardUnknown() {
	xxx_messageInfo_Anime_Tag.DiscardUnknown(m)
}

var xxx_messageInfo_Anime_Tag proto.InternalMessageInfo

type isAnime_Tag_Source interface {
	isAnime_Tag_Source()
}

type Anime_Tag_AnidbId struct {
	AnidbId int32 `protobuf:"zigzag32,10,opt,name=anidb_id,json=anidbId,proto3,oneof"`
}

func (*Anime_Tag_AnidbId) isAnime_Tag_Source() {}

func (m *Anime_Tag) GetSource() isAnime_Tag_Source {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *Anime_Tag) GetAnidbId() int32 {
	if x, ok := m.GetSource().(*Anime_Tag_AnidbId); ok {
		return x.AnidbId
	}
	return 0
}

func (m *Anime_Tag) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Anime_Tag) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Anime_Tag) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Anime_Tag_AnidbId)(nil),
	}
}

func init() {
	proto.RegisterEnum("data.Episode_Type", Episode_Type_name, Episode_Type_value)
	proto.RegisterEnum("data.Anime_Type", Anime_Type_name, Anime_Type_value)
	proto.RegisterType((*Episode)(nil), "data.Episode")
	proto.RegisterType((*Anime)(nil), "data.Anime")
	proto.RegisterType((*Anime_Source)(nil), "data.Anime.Source")
	proto.RegisterType((*Anime_Tag)(nil), "data.Anime.Tag")
}

func init() {
	proto.RegisterFile("data/anime.proto", fileDescriptor_026676bd538d663f)
}

var fileDescriptor_026676bd538d663f = []byte{
	// 552 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x93, 0xd1, 0x6e, 0xd3, 0x3e,
	0x14, 0xc6, 0xe7, 0x26, 0x6d, 0x92, 0xd3, 0x75, 0xff, 0xd4, 0xfa, 0x0b, 0xc2, 0x26, 0xa4, 0xa8,
	0x0c, 0x14, 0x90, 0x28, 0xd2, 0x78, 0x82, 0x30, 0x22, 0xa8, 0x18, 0x1d, 0x72, 0xd7, 0xed, 0x32,
	0x72, 0x63, 0xab, 0x8a, 0xd4, 0x3a, 0x91, 0xed, 0x5c, 0xec, 0xf9, 0x78, 0x01, 0x1e, 0x09, 0xd9,
	0x49, 0xaa, 0x0e, 0xb8, 0xcb, 0xf9, 0xbe, 0x23, 0x1f, 0xfd, 0xbe, 0x73, 0x02, 0x21, 0xa3, 0x9a,
	0x7e, 0xa0, 0xa2, 0xdc, 0xf3, 0x79, 0x2d, 0x2b, 0x5d, 0x61, 0xd7, 0x28, 0xb3, 0x9f, 0x08, 0xbc,
	0xac, 0x2e, 0x55, 0xc5, 0x38, 0x7e, 0x03, 0xae, 0x7e, 0xac, 0x79, 0x84, 0x62, 0x94, 0x9c, 0x5d,
	0xe1, 0xb9, 0x69, 0x98, 0x77, 0xe6, 0xfc, 0xee, 0xb1, 0xe6, 0xc4, 0xfa, 0xf8, 0x19, 0x8c, 0x44,
	0xb3, 0xdf, 0x70, 0x19, 0x0d, 0x62, 0x94, 0x4c, 0x49, 0x57, 0x61, 0x0c, 0xae, 0xa0, 0x7b, 0x1e,
	0x39, 0x31, 0x4a, 0x02, 0x62, 0xbf, 0xf1, 0x39, 0xf8, 0xac, 0x91, 0x54, 0x97, 0x95, 0x88, 0xdc,
	0x18, 0x25, 0x88, 0x1c, 0x6a, 0xfc, 0x02, 0x7c, 0x5a, 0xca, 0x9c, 0x51, 0xcd, 0xa3, 0x61, 0x8c,
	0x12, 0x4c, 0x3c, 0x5a, 0xca, 0xcf, 0x54, 0xf3, 0xd9, 0x7b, 0x70, 0xcd, 0x40, 0x3c, 0x06, 0x6f,
	0xbd, 0xfc, 0xb6, 0xbc, 0x7d, 0x58, 0x86, 0x27, 0xa6, 0x20, 0xd9, 0x97, 0xf5, 0x4d, 0x4a, 0x42,
	0x64, 0x8a, 0xd5, 0x8f, 0xec, 0x7a, 0x91, 0xde, 0x84, 0x83, 0xd9, 0xaf, 0x21, 0x0c, 0x53, 0xc3,
	0x86, 0xdf, 0xc1, 0x48, 0x55, 0x8d, 0x2c, 0x5a, 0x8a, 0x71, 0x4f, 0x61, 0xcd, 0xf9, 0xca, 0x3a,
	0xa4, 0xeb, 0xc0, 0x97, 0x1d, 0xef, 0xc0, 0xf2, 0x86, 0xc7, 0x9d, 0x47, 0xb4, 0xff, 0xc3, 0x50,
	0x97, 0x7a, 0xd7, 0x63, 0xb5, 0x05, 0x7e, 0x09, 0x50, 0x57, 0x4a, 0x73, 0x99, 0x37, 0x72, 0x67,
	0xc9, 0x02, 0x12, 0xb4, 0xca, 0x5a, 0xee, 0xf0, 0x6b, 0x38, 0xe3, 0x6d, 0x70, 0x2a, 0x2f, 0xaa,
	0x46, 0x68, 0x0b, 0x38, 0x25, 0x93, 0x5e, 0xbd, 0x36, 0x22, 0x7e, 0x0b, 0x7e, 0x2f, 0x44, 0xa3,
	0xd8, 0x49, 0xc6, 0x57, 0x93, 0x27, 0xa9, 0x93, 0x83, 0x6d, 0x06, 0x2a, 0x4d, 0xa5, 0x6e, 0xe3,
	0xf2, 0x6c, 0x5c, 0x81, 0x55, 0x4c, 0x60, 0x26, 0x4b, 0x2e, 0x58, 0x6b, 0xfa, 0x6d, 0x96, 0x5c,
	0x30, 0x6b, 0xbd, 0x02, 0x57, 0xd3, 0xad, 0x8a, 0x02, 0x3b, 0xe0, 0xbf, 0x27, 0x98, 0x74, 0x4b,
	0xac, 0x69, 0x76, 0x6a, 0xb6, 0x22, 0xb6, 0x11, 0xd8, 0x2d, 0x75, 0x15, 0x8e, 0x61, 0xcc, 0xb8,
	0x2a, 0x64, 0x59, 0xdb, 0x15, 0x8e, 0x2d, 0xe8, 0xb1, 0x84, 0x2f, 0xe1, 0x4c, 0xc9, 0x22, 0x2f,
	0x24, 0xa7, 0x9a, 0xb3, 0x9c, 0xea, 0xe8, 0xd4, 0xce, 0x3f, 0x55, 0xb2, 0xb8, 0x6e, 0xc5, 0x54,
	0xf7, 0x5d, 0x4d, 0xcd, 0xfa, 0xae, 0xc9, 0xa1, 0x6b, 0xdd, 0x8a, 0xa9, 0x3e, 0x7f, 0x80, 0x51,
	0xbb, 0x23, 0x7c, 0x01, 0x01, 0x15, 0x25, 0xdb, 0xe4, 0x25, 0x53, 0x11, 0x8a, 0x9d, 0x64, 0x4a,
	0x7c, 0x2b, 0x2c, 0x98, 0xc2, 0xcf, 0xc1, 0xdb, 0xd3, 0x9d, 0xb5, 0x06, 0xd6, 0x1a, 0xed, 0xe9,
	0xae, 0x33, 0xa8, 0x10, 0xd6, 0x70, 0x5a, 0x83, 0x0a, 0xb1, 0x60, 0xea, 0x7c, 0x03, 0xce, 0x1d,
	0xdd, 0xe2, 0x0b, 0xf0, 0xfb, 0x57, 0x2d, 0xe7, 0xf4, 0xeb, 0x09, 0xf1, 0xba, 0x67, 0x0f, 0xe7,
	0x8b, 0x8e, 0xce, 0xf7, 0x0f, 0xfc, 0xc1, 0x5f, 0xf8, 0x9f, 0xfc, 0xfe, 0xe0, 0x66, 0x37, 0xff,
	0xba, 0xd9, 0x09, 0x04, 0x77, 0xf7, 0xf9, 0x2a, 0x23, 0x8b, 0x6c, 0x15, 0x22, 0xec, 0x81, 0x73,
	0x7b, 0x9f, 0x86, 0x03, 0xfb, 0xb1, 0x4c, 0x43, 0x07, 0x07, 0x30, 0xfc, 0x7e, 0x7b, 0xbf, 0xc8,
	0x42, 0xf7, 0xf8, 0xa4, 0x87, 0x9b, 0x91, 0xfd, 0x4b, 0x3f, 0xfe, 0x0e, 0x00, 0x00, 0xff, 0xff,
	0xd8, 0x36, 0x73, 0xe7, 0xb9, 0x03, 0x00, 0x00,
}
